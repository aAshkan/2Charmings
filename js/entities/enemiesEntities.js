////////////// Enemy entities /////////////////////////////////////// enemy1// enemy1 walks from left to right & right to leftgame.enemy1Entity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);		this.walkLeft = true;				// used to determine if walking left		this.startX = x;					// original pos.x		this.endX = x + settings.width - settings.spritewidth;	// end of path		this.setVelocity(3, 12);			// speed		this.collidable = true;		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		var weapon = me.game.getEntityByName("weapon")[0];		// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 means touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);				me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			me.game.remove(this);		}	},	update : function() {		if (!this.inViewport)		// do nothing if not in viewpoint			return false;		// movement		if (this.alive) {			// this enemie simply goes right to left, left to right			if (this.walkLeft && this.pos.x <= this.startX) {				this.walkLeft = false;			} else if (!this.walkLeft && this.pos.x >= this.endX) {				this.walkLeft = true;			}			this.flipX(this.walkLeft);			this.vel.x += (this.walkLeft) ? -this.accel.x * me.timer.tick : this.accel.x * me.timer.tick;		} else {			this.vel.x = 0;		}		// check and update movement (MelonJS)		this.updateMovement();		this.updateColRect(0, 90, 20, 50);					// collision box (red)		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	}});// enemy1 that drops a block when killed// enemy1 walks from left to right & right to leftgame.enemy1BEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);				this.walkLeft = true;				// used to determine if walking left		this.startX = x;					// original pos.x		this.endX = x + settings.width - settings.spritewidth;		// end of path		this.setVelocity(3, 12);			// speed		this.collidable = true;		this.flickTime = 10;		this.hit = false;		//this.updateColRect(-1, 0, -1, 0);			this.updateColRect(0, 90, 20, 50);			this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];		// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {					this.renderable.flicker(45);					this.hit = true;							this.setVelocity(0, 0);						this.vel.x = 0;					//this.vel.y = -this.maxVel.y * me.timer.tick;				}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			this.hit = true;			this.setVelocity(0, 0);				this.vel.x = 0; this.vel.y = 0;		}			},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;		// movement		if (this.hit){			this.collidable = false;			//this.vel.y = 0;			if (this.flickTime){				this.flickTime--;					}			else {			// spawn blockEntity				var n = new game.blockEntity(this.pos.x, this.pos.y + 35, {					sprite : 'block',					image : 'block',					spritewidth : 48,				});				me.game.add(n, 100);				me.game.draw();				me.game.sort();				me.game.remove(this);			}		}		else if (this.alive) {			// this enemie simply goes right to left, left to right			if (this.walkLeft && this.pos.x <= this.startX) {				this.walkLeft = false;			} else if (!this.walkLeft && this.pos.x >= this.endX) {				this.walkLeft = true;			}			this.flipX(this.walkLeft);			this.vel.x += (this.walkLeft) ? -this.accel.x * me.timer.tick : this.accel.x * me.timer.tick;		} else {				this.vel.x = 0;		}				this.updateMovement();		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	}});// enemy1 that drops 1 coin when killed// enemy1 walks from left to right & right to leftgame.enemy1CEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);		this.walkLeft = true;			// used to determin if walking left		this.startX = x;				// original pos.x		this.endX = x + settings.width - settings.spritewidth;		// end of path		this.setVelocity(3, 12);		// speed		this.collidable = true;		this.type = me.game.ENEMY_OBJECT;		// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {				// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];		// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);				// spawn coin				var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {					sprite : 'coins',					image : 'coins',					spritewidth : 32,				});				me.game.add(n, 100);				me.game.draw();				me.game.sort();				me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			// spawn coin			var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {				sprite : 'coins',				image : 'coins',				spritewidth : 32,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;					// movement		if (this.alive) {			// this enemie simply goes right to left, left to right spritewidth			if (this.walkLeft && this.pos.x <= this.startX) {				this.walkLeft = false;			} else if (!this.walkLeft && this.pos.x >= this.endX) {				this.walkLeft = true;			}			this.flipX(this.walkLeft);			this.vel.x += (this.walkLeft) ? -this.accel.x * me.timer.tick : this.accel.x * me.timer.tick;		} else {			this.vel.x = 0;		}				// check and update movement		this.updateMovement();		this.updateColRect(0, 90, 20, 50);					// collision box (red)		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	}});// enemy2// enemy 2 is a flying enemy that will follow you if you are within rangegame.enemy2Entity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);		this.startX = x;		// start pos.x		this.startY = y;		// start pos.y		this.inRangeB = false;	// boy is in range		this.inRangeG = false;	// girl is in range		this.setVelocity(0, 0);	// speed		this.origin = true;		this.collidable = true;		this.gravity = 0;		// so it can fly		this.type = me.game.ENEMY_OBJECT;		// of ENEMY_OBJECT type		this.dead = false;		this.renderable.addAnimation("spin", [0,1,2]);		this.renderable.setCurrentAnimation("spin");	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);				this.dead = true;				me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N			else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			this.dead = true;			me.game.remove(this);		}	},	update : function() {	  this.renderable.setCurrentAnimation("spin");		// do nothing if not in viewpoint		if (!this.inViewport)			return false;		// Prince & Princess		var boy = me.game.getEntityByName("boy")[0];		// boy = boyEntity		var girl = me.game.getEntityByName("girl")[0];		// girl = girlEntity				// what we want to constantly be updated		this.checkRange(boy, girl);		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)					// AI of enemy		if (!this.inRangeB && !this.inRangeG && this.origin) {			this.setVelocity(0, 0);			return false;		}		if (this.inRangeB) {			this.setVelocity(2, 2);			this.moveToPlayerB(boy);			return false;		} else if (this.inRangeG) {			this.setVelocity(2, 2);			this.moveToPlayerG(girl);			return false;		} else {			this.setVelocity(2, 2);			this.moveToStart();			return false;		}		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0 || !this.dead) {			// update object animation			this.parent();			return true;		}		return false;	},	// function that determines if either the boy or girl are in range	checkRange : function(boy, girl) {		// check inRangeB		if (this.distanceTo(boy) < 250) {			this.inRangeB = true;		} else {			this.inRangeB = false;		}		// check inRangeG		if (this.distanceTo(girl) < 250) {			this.inRangeG = true;		} else {			this.inRangeG = false;		}		// check origin		if ((this.pos.x == this.starX) && (this.pos.y == this.startY)) {			this.origin = true;		} else {			this.origin = false;		}	},	// function that moves towards nearest player	moveToPlayerB : function(boy) {		// x - axix		if (boy.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick;		} else if (boy.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (boy.pos.y > this.pos.y) {			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (boy.pos.y < this.pos.y) {			/// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (boy.pos.x == this.pos.x) {			this.vel.x = 0;		}		if (boy.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards nearest player	moveToPlayerG : function(girl) {		// x - axis		if (girl.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick / 2;		} else if (girl.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (girl.pos.y > this.pos.y) {			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (girl.pos.y < this.pos.y) {			// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (girl.pos.x == this.pos.y) {			this.vel.x = 0;		}		if (girl.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards origin	moveToStart : function() {		if (this.origin) {			this.setVelocity(0, 0);			return true;		}		if (this.startX > this.pos.x) {			// enemy left of origin			this.vel.x += this.accel.x * me.timer.tick;		} else {			// enemy right of origin			this.vel.x -= this.accel.x * me.timer.tick;		}		if (this.startY > this.pos.y) {			// enemy below origin			this.vel.y += this.accel.y * me.timer.tick;		} else {			// enemy above origin			this.vel.y -= this.accel.y * me.timer.tick;		}	},});// enemy2B// enemy 2 that drops a blockgame.enemy2BEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/		this.parent(x, y, settings);		this.startX = x;		// start pos.x		this.startY = y;		// start pos.y		this.inRangeB = false;	// boy is in range		this.inRangeG = false;	// girl is in range		this.setVelocity(0, 0);	// speed		this.origin = true;		this.collidable = true;		this.gravity = 0;		// so it can fly		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);							// spawn block 			var n = new game.blockEntity(this.pos.x, this.pos.y + 35, {				sprite : 'block',				image : 'block',				spritewidth : 48,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);						// spawn block 			var n = new game.blockEntity(this.pos.x, this.pos.y + 35, {				sprite : 'block',				image : 'block',				spritewidth : 48,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;					// Prince & Princess		var boy = me.game.getEntityByName("boy")[0];		// boy = boyEntity		var girl = me.game.getEntityByName("girl")[0];		// girl = girlEntity		// what we want to constantly be updated		this.checkRange(boy, girl);		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)				// AI of enemy		if (!this.inRangeB && !this.inRangeG && this.origin) {			this.setVelocity(0, 0);			return false;		}		if (this.inRangeB) {			this.setVelocity(2, 2);			this.moveToPlayerB(boy);			return false;		} else if (this.inRangeG) {			this.setVelocity(2, 2);			this.moveToPlayerG(girl);			return false;		} else {			this.setVelocity(2, 2);			this.moveToStart();			return false;		}		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	// function that determines if either the boy or girl are in range	checkRange : function(boy, girl) {		// check inRangeB		if (this.distanceTo(boy) < 250) {			this.inRangeB = true;		} else {			this.inRangeB = false;		}		// check inRangeG		if (this.distanceTo(girl) < 250) {			this.inRangeG = true;		} else {			this.inRangeG = false;		}		// check origin		if ((this.pos.x == this.starX) && (this.pos.y == this.startY)) {			this.origin = true;		} else {			this.origin = false;		}	},	// function that moves towards nearest player	moveToPlayerB : function(boy) {				// x - axix		if (boy.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick;		} else if (boy.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}				// y - axis		if (boy.pos.y > this.pos.y) {			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (boy.pos.y < this.pos.y) {			/// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (boy.pos.x == this.pos.x) {			this.vel.x = 0;		}		if (boy.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards nearest player	moveToPlayerG : function(girl) {				// x - axis		if (girl.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick / 2;		} else if (girl.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (girl.pos.y > this.pos.y) {			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (girl.pos.y < this.pos.y) {			// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (girl.pos.x == this.pos.y) {			this.vel.x = 0;		}		if (girl.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards origin	moveToStart : function() {				if (this.origin) {			this.setVelocity(0, 0);			return true;		}		// x -axis		if (this.startX > this.pos.x) {			// enemy left of origin			this.vel.x += this.accel.x * me.timer.tick;		} else {			// enemy right of origin			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (this.startY > this.pos.y) {			// enemy below origin			this.vel.y += this.accel.y * me.timer.tick;		} else {			// enemy above origin			this.vel.y -= this.accel.y * me.timer.tick;		}	},});// enemy2C// enemy 2 that moves in a square pathgame.enemy2CEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/				this.parent(x, y, settings);		this.startX = x;					// start pos.x		this.startY = y;					// start pos.y		this.inRangeB = false;				// boy is in range			this.inRangeG = false;				// girl is in range		this.setVelocity(0, 0);				// speed		this.origin = true;		this.collidable = true;		this.gravity = 0;					// so it can fly		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {			// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);							// spawn block 			var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {				sprite : 'coins',				image : 'coins',				spritewidth : 32,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);			}		}				// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);						// spawn coin entity 			var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {				sprite : 'coins',				image : 'coins',				spritewidth : 32,			});						me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;		// Prince & Princess		var boy = me.game.getEntityByName("boy")[0];		// boy = boyEntity		var girl = me.game.getEntityByName("girl")[0];		// girl = girlEntity				// what we want to constantly be updated		this.checkRange(boy, girl);		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)				// AI of enemy		if (!this.inRangeB && !this.inRangeG && this.origin) {			this.setVelocity(0, 0);			return false;		}		if (this.inRangeB) {			this.setVelocity(2, 2);			this.moveToPlayerB(boy);			return false;		} else if (this.inRangeG) {			this.setVelocity(2, 2);			this.moveToPlayerG(girl);			return false;		} else {			this.setVelocity(2, 2);			this.moveToStart();			return false;		}		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	// function that determines if either the boy or girl are in range	checkRange : function(boy, girl) {		// check inRangeB		if (this.distanceTo(boy) < 250) {			this.inRangeB = true;		} else {			this.inRangeB = false;		}		// check inRangeG		if (this.distanceTo(girl) < 250) {			this.inRangeG = true;		} else {			this.inRangeG = false;		}		// check origin		if ((this.pos.x == this.starX) && (this.pos.y == this.startY)) {			this.origin = true;		} else {			this.origin = false;		}	},	// function that moves towards Prince	moveToPlayerB : function(boy) {		// x - axix		if (boy.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick;		} else if (boy.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (boy.pos.y > this.pos.y){ 			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (boy.pos.y < this.pos.y) {			/// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (boy.pos.x == this.pos.x) {			this.vel.x = 0;		}		if (boy.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards Princess 	moveToPlayerG : function(girl) {		// x - axis		if (girl.pos.x > this.pos.x) {			// enemy left to player			this.vel.x += this.accel.x * me.timer.tick / 2;		} else if (girl.pos.x < this.pos.x) {			// enemy right to player			this.vel.x -= this.accel.x * me.timer.tick;		}		// y - axis		if (girl.pos.y > this.pos.y) {			// enemy above player			this.vel.y += this.accel.y * me.timer.tick;		} else if (girl.pos.y < this.pos.y) {			// enemy below player			this.vel.y -= this.accel.y * me.timer.tick;		}		// if on position w/ player don't move		if (girl.pos.x == this.pos.y) {			this.vel.x = 0;		}		if (girl.pos.y == this.pos.y) {			this.vel.y = 0;		}	},	// function that moves towards origin	moveToStart : function() {				// at origin so do nothing		if (this.origin) {			this.setVelocity(0, 0);			return true;		}				// x -axis		if (this.startX > this.pos.x) {			// enemy left of origin			this.vel.x += this.accel.x * me.timer.tick;		} else {			// enemy right of origin			this.vel.x -= this.accel.x * me.timer.tick;		}				// y - axis		if (this.startY > this.pos.y) {			// enemy below origin			this.vel.y += this.accel.y * me.timer.tick;		} else {			// enemy above origin			this.vel.y -= this.accel.y * me.timer.tick;		}	},});// enemy2S// enemy 2 that moves in a square pathgame.enemy2SEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/				this.parent(x, y, settings);		this.startX = x;			// start pos.x		this.startY = y;			// start pos.y		this.X2 = x + settings.width - settings.spritewidth;		// other x corrdinate we want to check for		this.Y2 = y + settings.height - settings.spriteheight;		// other y corrdinate we want to check for		this.setVelocity(2, 2);		// speed		this.collidable = true;		this.gravity = 0;			// so it can fly		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);				me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;				// what we want to constantly be updated		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)					// AI of enemy		this.squarePath();		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	squarePath : function() {				if (((this.pos.y == this.startY) || (this.pos.y < this.startY)) && !(this.pos.x > this.X2)) {			// moving right			this.vel.y = 0;			this.vel.x += this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.X2) || (this.pos.x > this.X2)) && !(this.pos.y > this.Y2)) {			// moving down			this.vel.x = 0;			this.vel.y += this.accel.y * me.timer.tick;		}else if (((this.pos.y == this.Y2) || (this.pos.y > this.Y2)) && !(this.pos.x < this.startX)) {			// moving right			this.vel.y = 0;			this.vel.x -= this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.startX) || (this.pos.x < this.startX)) && !(this.pos.y < this.startY)) {			// moving up			this.vel.x = 0;			this.vel.y -= this.accel.y * me.timer.tick;		}			},});// enemy2S// enemy 2 that moves in a square path and drops a blockgame.enemy2SBEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/				this.parent(x, y, settings);		this.startX = x;			// start pos.x		this.startY = y;			// start pos.y		this.X2 = x + settings.width - settings.spritewidth;		// other x corrdinate we want to check for		this.Y2 = y + settings.height - settings.spriteheight;		// other y corrdinate we want to check for		this.setVelocity(2, 2);		// speed		this.collidable = true;		this.gravity = 0;			// so it can fly		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);						// spawn block 			var n = new game.blockEntity(this.pos.x, this.pos.y + 35, {				sprite : 'block',				image : 'block',				spritewidth : 48,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);						// spawn block 			var n = new game.blockEntity(this.pos.x, this.pos.y + 35, {				sprite : 'block',				image : 'block',				spritewidth : 48,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;				// what we want to constantly be updated		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)					// AI of enemy		this.squarePath();		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	squarePath : function() {				if (((this.pos.y == this.startY) || (this.pos.y < this.startY)) && !(this.pos.x > this.X2)) {			// moving right			this.vel.y = 0;			this.vel.x += this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.X2) || (this.pos.x > this.X2)) && !(this.pos.y > this.Y2)) {			// moving down			this.vel.x = 0;			this.vel.y += this.accel.y * me.timer.tick;		}else if (((this.pos.y == this.Y2) || (this.pos.y > this.Y2)) && !(this.pos.x < this.startX)) {			// moving right			this.vel.y = 0;			this.vel.x -= this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.startX) || (this.pos.x < this.startX)) && !(this.pos.y < this.startY)) {			// moving up			this.vel.x = 0;			this.vel.y -= this.accel.y * me.timer.tick;		}			},});// enemy2S// enemy 2 that moves in a square path and drops a coingame.enemy2SCEntity = me.ObjectEntity.extend({	init : function(x, y, settings) {/*constructor*/				this.parent(x, y, settings);		this.startX = x;			// start pos.x		this.startY = y;			// start pos.y		this.X2 = x + settings.width - settings.spritewidth;		// other x corrdinate we want to check for		this.Y2 = y + settings.height - settings.spriteheight;		// other y corrdinate we want to check for		this.setVelocity(2, 2);		// speed		this.collidable = true;		this.gravity = 0;			// so it can fly		this.type = me.game.ENEMY_OBJECT;	// of ENEMY_OBJECT type	},	onCollision : function(res, obj) {		// weapon = weaponEntity		var weapon = me.game.getEntityByName("weapon")[0];				// determine if being attacked by the weapon - Y/die - N/N		if (weapon.attacking == true) {			// res.y > 0 meands touched by something on the bottom			if (this.alive && ((res.y > 0 && obj.falling ) || (obj.name == "weapon" && weapon.attacking))) {				this.renderable.flicker(45);			// spawn coin			var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {				sprite : 'coins',				image : 'coins',				spritewidth : 32,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);			}		}		// determing if being jumped on by boyEntity or girlEntity - Y/die - N/N		else if (this.alive && ((res.y > 0 && obj.falling ) && ((obj.name == ("boy") || (obj.name == ("girl")))))) {			this.renderable.flicker(45);			// spawn coin			var n = new game.coinsEntity(this.pos.x, this.pos.y + 35, {				sprite : 'coins',				image : 'coins',				spritewidth : 32,			});			me.game.add(n, 100);			me.game.draw();			me.game.sort();			me.game.remove(this);		}	},	update : function() {		// do nothing if not in viewpoint		if (!this.inViewport)			return false;				// what we want to constantly be updated		this.updateMovement();		this.updateColRect(0, 100, 8, 100);					// collision box (red)					// AI of enemy		this.squarePath();		// update animation if necessary		if (this.vel.x != 0 || this.vel.y != 0) {			// update object animation			this.parent();			return true;		}		return false;	},	squarePath : function() {				if (((this.pos.y == this.startY) || (this.pos.y < this.startY)) && !(this.pos.x > this.X2)) {			// moving right			this.vel.y = 0;			this.vel.x += this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.X2) || (this.pos.x > this.X2)) && !(this.pos.y > this.Y2)) {			// moving down			this.vel.x = 0;			this.vel.y += this.accel.y * me.timer.tick;		}else if (((this.pos.y == this.Y2) || (this.pos.y > this.Y2)) && !(this.pos.x < this.startX)) {			// moving right			this.vel.y = 0;			this.vel.x -= this.accel.x * me.timer.tick;		}else if (((this.pos.x == this.startX) || (this.pos.x < this.startX)) && !(this.pos.y < this.startY)) {			// moving up			this.vel.x = 0;			this.vel.y -= this.accel.y * me.timer.tick;		}			},});